Name     INTERRUPT_GAL ;
PartNo   00 ;
Date     17/04/2024 ;
Revision 01 ;
Designer Tom Storey ;
Company  COMET68k ;
Assembly None ;
Location None ;
Device   g16v8a ;

/* Interruptor machine states */
$DEFINE M_WAITING 'b'0
$DEFINE M_REQUESTING 'b'1

/*********************************** INPUTS ************************************/
PIN 1 = clk;
PIN 2 = !iackin;
PIN 3 = !iack;
PIN 4 = irq_en;
PIN 8 = !irq_in1;
PIN 9 = irq_in2;

/*********************************** OUTPUTS ***********************************/
PIN 17 = !irq_drv;
PIN 18 = !vec;
PIN 19 = !iackout;

/********************************** INTERNAL ***********************************/
PIN 12 = state;

/********************************** EQUATIONS **********************************/

/* Assert IRQ whenever either of the IRQ inputs is asserted */
irq_drv = irq_en & (irq_in1 # irq_in2);

/* IACKIN may only be passed along if we are not an active interruptor that is
 * being acknowledged */
iackout = iackin & (state:M_WAITING #
                    state:M_REQUESTING & !iack);

/* Assert vector acquire output during interrupt acknowledge when we are the
 * interruptor being serviced */
vec = iackin & state:M_REQUESTING & iack;

/* Interruptor state machine
 *
 * The state machine determines how and when the IACKIN and vector acquire
 * signals are handled.
 *
 * When we are an active interruptor and we are being acknowledged, the IACKIN
 * signal will not be daisy chained to further slots and we can assert our vector
 * acquire signal to other logic which is then responsible for determining how to
 * generate a response to the CPU.
 *
 * When we are not an active interruptor or if we are not being acknowledged in
 * the current IACK cycle, the IACKIN signal is daisy chained to further slots
 * and we do not assert our vector acquire signal.
 */
SEQUENCE state {
	/* In this state we are waiting for an interrupt to be generated by the
	 * attached peripheral. Once an interrupt is generated, and as long as the
	 * IACKIN signal is negated (indicating that no other interrupts are being
	 * serviced at this time), move to the requesting state such that we can
	 * respond to the interrupt acknowledge cycle for our interrupt. */
	PRESENT M_WAITING
		IF irq_en & (irq_in1 # irq_in2) & !iackin NEXT M_REQUESTING;
		DEFAULT NEXT M_WAITING;

	/* Remain in the requesting state as long as our attached device is still
	 * generating an interrupt, and interrupts are still enabled. */
	PRESENT M_REQUESTING
		IF !irq_in1 & !irq_in2 # !irq_en NEXT M_WAITING;
		DEFAULT NEXT M_REQUESTING;
}

/* END */
